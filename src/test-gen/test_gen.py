#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
File: test_gen.py
Description: Geneates test cases to validate the functionality of the output of the bit-serial compiler using PIMeval
Author: Mohammadhosein Gholamrezaei <uab9qt@virginia.edu>
Author: Deyuan Guo <guodeyuan@gmail.com> - Bit-wise C test code generation
Date: 2025-04-05
"""

import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from util import *

class OperandsListGenerator():
    def __init__(self, operator, dataType):
        self.operator = operator
        self.dataType = dataType

    def getOperandsCount(self):
        oneOperand = ["not", "abs", "popcount"]
        twoOperand = ["add", "sub", "mul", "and", "or", "xor", "xnor", "mul", "min", "max", "lt", "gt", "eq", "ne", "shift_l", "shift_r"]

        if self.operator in oneOperand:
            return 1
        if self.operator in twoOperand:
            return 2
        raise Exception(f"Error: operator {self.operator} is not handled.")

    def getInputsList(self):
        if self.getOperandsCount() == 1: return [("a", self.dataType)]
        if self.getOperandsCount() == 2: return [("a", self.dataType), ("b", self.dataType)]
        raise Exception(f"Error: number of input operands is more than 2 which is not handled.")

    def getOutputsList(self):
        return [("z", self.dataType)]
        raise Exception(f"Error: number of input operands is more than 2 which is not handled.")

    def getOperands(self):
        return self.getInputsList(), self.getOutputsList()

class TestGenerator:
    def __init__(self, moduleName, outputPath, numTests, inputOperands, outputOperands, operator, pimMode = "digital", goldenFunctionFilePath=None, goldenFunctionName=None):
        self.moduleName = moduleName
        self.outputPath = outputPath
        self.numTests = numTests
        self.inputOperands = inputOperands
        self.outputOperands = outputOperands
        self.operator = operator
        self.pimMode = pimMode
        self.goldenFunctionFilePath = goldenFunctionFilePath
        self.goldenFunctionName = goldenFunctionName


    def generateMakeFile(self):
        makefileStr = f"""
# Automatically generated by bit-serial compiler

REPO_ROOT := $(shell git rev-parse --show-toplevel)
LIB_PIMEVAL_PATH := $(REPO_ROOT)/PIMeval-PIMbench/libpimeval

GCC = gcc
CXX = g++
CXXFLAGS = -I$(LIB_PIMEVAL_PATH)/include # Path to header files
LDFLAGS = -L$(LIB_PIMEVAL_PATH)/lib -l:libpimeval.a # Path to static library and linking

TARGET_PIM = {self.moduleName}.test.out
TARGET_BITWISE = {self.moduleName}.test_bitwise.out

all: $(TARGET_PIM) $(TARGET_BITWISE)

$(TARGET_PIM): {self.moduleName}.test.cpp
	$(CXX) $(CXXFLAGS) $< -o $@ $(LDFLAGS)

$(TARGET_BITWISE): {self.moduleName}.test_bitwise.c
	$(GCC) $< -o $@

clean:
	rm -f $(TARGET_PIM) $(TARGET_BITWISE)
"""
        return makefileStr

    def getBound(self):
        dataType = self.outputOperands[0][1]
        return 2 ** self.getCDataWidth(dataType)

    def getGoldenFunctionStatement(self, operator):
        operand = self.outputOperands[0][0]
        dataType = self.outputOperands[0][1]
        opDict = {
            "add": f'a + b',
            "sub": f'a - b',
            "mul": f'a * b',
            "and": f'a & b',
            "or": f'a | b',
            "xor": f'a ^ b',
            "xnor": f'~(a ^ b)',
            "max": f'(a > b)?a:b',
            "min": f'(a < b)?a:b',
            "abs": f'(a > 0)?a:-a',
            "not": f'~a',
            "lt": f'(a < b)',
            "gt": f'(a > b)',
            "eq": f'(a == b)',
            "ne": f'(a != b)',
            "popcount": f'std::bitset<{dataType[3:]}>(a).count()' if dataType else None,
            "shift_l": f'a << b',
            "shift_r": f'a >> b',
        }

        expression = opDict.get(operator)
        if expression is None:
            return None
        return f"*{operand} = ({expression}) % {self.getBound()};"


    def getCDatatype(self, dataType):
        if dataType in {"int1", "int2", "int3", "int4"}:
            return "int8_t"
        elif dataType in {"uint1", "uint2", "uint3", "uint4"}:
            return "uint8_t"
        return f"{dataType}_t"

    def getCDataWidth(self, dataType):
        if dataType.startswith("int") and dataType[3:].isdigit():
            return int(dataType[3:])
        elif dataType.startswith("uint") and dataType[4:].isdigit():
            return int(dataType[4:])
        raise Exception(f"Unknown data type: {dataType}")

    def getPimEvalDataType(self, dataType):
        if dataType in {"int1", "int2", "int3", "int4", "int8"}:
            return "PIM_INT8"
        elif dataType in {"uint1", "uint2", "uint3", "uint4", "uint8"}:
            return "PIM_UINT8"
        if dataType.startswith("int") or dataType.startswith("uint"):
            return f"PIM_{dataType.upper()}"
        raise ValueError(f"Unknown data type: {dataType}")

    def getPimObjList(self):
        return [f"{operand}Pim" for operand, _ in self.inputOperands]

    def getInputsStr(self, withType=False):
        inputs = [
            f"{self.getCDatatype(dataType)} {operand}" if withType else operand
            for operand, dataType in self.inputOperands
        ]
        return ", ".join(inputs)

    def getOutputsStr(self, withType=False, withAsterisk=False, withReference=False):
        output_parts = []

        for operand, dataType in self.outputOperands:
            if withType:
                ctype = self.getCDatatype(dataType)
                prefix = f"{ctype}* " if withAsterisk else f"{ctype} "
                output_parts.append(f"{prefix}{operand}")
            else:
                if withReference:
                    output_parts.append(f"&{operand}")
                elif withAsterisk:
                    output_parts.append(f"*{operand}")
                else:
                    output_parts.append(operand)

        return ", ".join(output_parts)

    def getPimObjsStr(self, withType=False):
        operands = self.inputOperands + self.outputOperands
        objs = [
            f"PimObjId {operand}Pim" if withType else f"{operand}Pim"
            for operand, _ in operands
        ]
        return ", ".join(objs)

    def getOutputsDeclarationStr(self, withResult=False):
        return "\n\t".join(
            f"{self.getCDatatype(dataType)} {operand}_res;" if withResult else f"{self.getCDatatype(dataType)} {operand};"
            for operand, dataType in self.outputOperands
        ) + ("\n\t" if self.outputOperands else "")

    def getGoldenFunctionName(self):
        if self.goldenFunctionName is None:
            return f"{self.moduleName}_golden"
        return self.goldenFunctionName

    def generateGoldenFunctionFile(self):
        if not self.goldenFunctionFilePath is None:
            code = getContent(self.goldenModelHeaderFile)
        else:
            outputOperandType = self.outputOperands[0][1]
            functionName = self.getGoldenFunctionName()
            code = f"#ifndef {functionName.upper()}_H\n"
            code += f"#define {functionName.upper()}_H\n"
            signature = f"void {functionName}({self.getInputsStr(withType=True)}, {self.getOutputsStr(withType=True, withAsterisk=True)})"
            testStatmentStr = self.getGoldenFunctionStatement(self.operator)
            if testStatmentStr is None:
                raise Exception("Error: The test generator does not support {self.operator} operator.")
            code += f"""
    {signature} {{
      {testStatmentStr}
      return;
    }}\n\n
    """
            code += "#endif\n\n"
        return code

    def getPimCopyHosttoDeviceStr(self):
        returnStr = ""
        for (operand, dataType) in self.inputOperands:
            returnStr += f"pimCopyHostToDevice(&{operand}, {operand}Pim);\n\t"
        return returnStr

    def getPimCopyDeviceToHost(self):
        returnStr = ""
        for (operand, dataType) in self.outputOperands:
            returnStr += f"pimCopyDeviceToHost({operand}Pim, &{operand}_res);\n\t"
        return returnStr

    def getCoutStr(self):
        returnStr = ""
        i = 0
        for (operand, dataType) in self.inputOperands:
            returnStr += f"\"Input {operand} = \" << (int) {operand} << "
            if (i != len(self.inputOperands) - 1):
                returnStr += "\", \" << "
            i+= 1
        return returnStr

    def getPimAllocStr(self):
        returnStr = ""
        firstObj = f"{self.inputOperands[0][0]}Pim"
        firstObjDataType = self.inputOperands[0][1]
        returnStr += f"PimObjId {firstObj} = pimAlloc(PIM_ALLOC_V, 1, {self.getPimEvalDataType(firstObjDataType)});\n\t"
        for (operand, dataType) in self.inputOperands[1:] + self.outputOperands:
            obj = f"{operand}Pim"
            returnStr += f"PimObjId {obj} = pimAllocAssociated({firstObj}, {self.getPimEvalDataType(dataType)});\n\t"
        return returnStr

    def getRandGenStr(self, cStyle=False):
        returnStr = ""
        randFunc = "rand()" if cStyle else "std::rand()"
        for i, (operand, dataType) in enumerate(self.inputOperands):
            if self.operator in ["shift_l", "shift_r"] and i == 1:
                bound = self.getCDataWidth(dataType)  # limit the shift amount to the data width
            else:
                bound = 2 ** self.getCDataWidth(dataType)
            returnStr += f"{self.getCDatatype(dataType)} {operand} = {randFunc} % {bound};\n\t\t"
        return returnStr

    def getPrintAllOperandsStr(self, cStyle=False):
        returnStr = ""

        def getPrintfFormat(dataType):
            formatDict = {
                "int1": "%d",
                "int2": "%d",
                "int3": "%d",
                "int4": "%d",
                "int8": "%d",
                "int16": "%d",
                "int32": "%d",
                "int64": "%ld",
                "uint8": "%u",
                "uint16": "%u",
                "uint32": "%u",
                "uint64": "%lu",
                "float": "%f",
                "double": "%lf",
            }
            return formatDict.get(dataType, "%d")  # default to %d

        for (operand, dataType) in self.inputOperands:
            if cStyle:
                fmt = getPrintfFormat(dataType)
                returnStr += f'printf("{operand}: {fmt}\\n", ({self.getCDatatype(dataType)}) {operand});\n\t'
            else:
                returnStr += f'std::cerr << "{operand}: " << ({self.getCDatatype(dataType)}) {operand} << std::endl;\n\t'

        for (operand, dataType) in self.outputOperands:
            if cStyle:
                fmt = getPrintfFormat(dataType)
                returnStr += f'printf("{operand}(expected): {fmt}\\n", ({self.getCDatatype(dataType)}) {operand});\n\t'
                returnStr += f'printf("{operand}(pim     ): {fmt}\\n", ({self.getCDatatype(dataType)}) {operand});\n\t'
            else:
                returnStr += f'std::cerr << "{operand}(expected): " << ({self.getCDatatype(dataType)}) {operand} << std::endl;\n\t'
                returnStr += f'std::cerr << "{operand}(pim     ): " << ({self.getCDatatype(dataType)}) {operand} << std::endl;\n\t'

        return returnStr


    def getVerificationCodeStr(self, cStyle=False):
        returnStr = ""
        for (operand, dataType) in self.outputOperands:
            returnStr += f"""
    if ({operand} != {operand}_res) {{
        {self.getPrintAllOperandsStr(cStyle)}
        return false;
    }}
            """
        return returnStr

    def getPimFreeStr(self):
        returnStr = ""
        for objStr in self.getPimObjList():
            returnStr += f"pimFree({objStr});\n\t"
        return returnStr

    def resolveGoldenFunctionPath(self):
        goldenFunctionFilePath = f"{self.moduleName}.golden.hpp"
        if not self.goldenFunctionFilePath is None:
            goldenFunctionFilePath = self.goldenFunctionFilePath
        return goldenFunctionFilePath

    def generatCppTestFile(self):
        goldenFunctionFilePath = self.resolveGoldenFunctionPath()
        inputsStrWithType = self.getInputsStr(withType=True)
        outputsStrWithType = self.getOutputsStr(withType=True)
        pimObjStrWithType = self.getPimObjsStr(withType=True)
        inputsStr = self.getInputsStr()
        outputStrWithReference = self.getOutputsStr(withReference=True)
        pimCopyHostToDeviceStr = self.getPimCopyHosttoDeviceStr()
        pimCopyDeviceToHostStr = self.getPimCopyDeviceToHost()

        pimObjsStr = self.getPimObjsStr()
        outputsDeclarationStr = self.getOutputsDeclarationStr()
        outputResultsDeclarationStr = self.getOutputsDeclarationStr(withResult=True)
        coutStr = self.getCoutStr()
        pimAllocStr = self.getPimAllocStr()
        randGenStr = self.getRandGenStr()
        pimFreeStr = self.getPimFreeStr()
        outputDataType = self.outputOperands[0][1]

        if self.pimMode == "digital":
            pimDevice = "PIM_DEVICE_BITSIMD_V"
        else:
            pimDevice = "PIM_DEVICE_SIMDRAM"
        testFileStr = f"""
// Automatically generated by bit-serial compiler
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <cstdint>
#include <bitset>
#include "{self.moduleName}.hpp"
#include "{goldenFunctionFilePath}"
#include "libpimeval.h"


bool runTest({inputsStrWithType}, {pimObjStrWithType}) {{
  // Declare the output signals
  {outputsDeclarationStr}
  {outputResultsDeclarationStr}

  // Calculate the expected result using the golden model
  {self.getGoldenFunctionName()}({inputsStr}, {outputStrWithReference});

  // Copy data to PIM device
  {pimCopyHostToDeviceStr}

  // Call the function under test
  {self.moduleName}({pimObjsStr});

  // Retrieve and verify the result from the PIM device
  {pimCopyDeviceToHostStr}

  {self.getVerificationCodeStr()}
  return true;
}}

int main() {{
  // Initialize random seed
  std::srand(static_cast<unsigned int>(std::time(nullptr)));

  // Initialize PIM device
  PimStatus status = pimCreateDevice({pimDevice}, 1, 1, 2, 1024, 1024);
  if (status != PIM_OK) {{
      std::cerr << "Error: Failed to create PIM device with default config" << std::endl;
      return -1;
  }}

  // Allocate PIM objects for the input/output vector with element size = 1
  {pimAllocStr}

  // Run random tests
  int numTests = {self.numTests};  // Number of random test cases
  bool allPassed = true;
  for (int testNumber = 1; testNumber <= numTests; ++testNumber) {{
      {randGenStr}

      pimResetStats();
      bool ok = runTest({inputsStr}, {pimObjsStr});
      allPassed &= ok;
      if (!ok) {{
          std::cerr << "Error: Test " << testNumber << " failed!" << std::endl;
      }} else {{
          std::cout << "Info: Test " << testNumber << " passed!" << std::endl;
      }}
  }}

  pimShowStats();
  if (allPassed) {{
      std::cout << "PIM test: ALL PASSED!" << std::endl;
  }} else {{
      std::cerr << "PIM test: SOME FAILED!" << std::endl;
  }}

  // Clean up and free allocated resources
  {pimFreeStr}
  pimDeleteDevice();

  return 0;
}}

"""
        return testFileStr

    def getBitwiseFuncCall(self):
        """ Call the bitwise function """
        funcCallStr = ''
        params = ''

        for (operand, dataType) in self.inputOperands:
            dataWidth = self.getCDataWidth(dataType)
            funcCallStr += f"""
            int bit_{operand}[{dataWidth}];
            for (int i = 0; i < {dataWidth}; i++) {{
                bit_{operand}[i] = {operand} & (1 << i) ? 1 : 0;
            }}
            """
            for i in range(dataWidth):
                params += f'bit_{operand}+{i}, '


        for (operand, dataType) in self.outputOperands:
            dataWidth = self.getCDataWidth(dataType)
            funcCallStr += f'\tint {operand}_bit_out[{dataWidth}];\n'
            for i in range(dataWidth):
                params += f'{operand}_bit_out+{i}, '

        params = params[:-2] # remove last comma and space
        funcCallStr += f'\tfunc({params});'

        for (operand, dataType) in self.outputOperands:
            dataWidth = self.getCDataWidth(dataType)
            funcCallStr += f"""
        {operand}_res = 0;
        for (int i = 0; i < {dataWidth}; i++) {{
            {operand}_res |= {operand}_bit_out[i] << i;
        }}
            """
        return funcCallStr

    def generatBitwiseTestFile(self):
        """ Generate test file for bitwise IR """
        goldenFunctionFilePath = self.resolveGoldenFunctionPath()
        inputsStrWithType = self.getInputsStr(withType=True)
        inputsStr = self.getInputsStr()
        randGenStr = self.getRandGenStr(cStyle=True)
        bitwiseOpStr = self.getBitwiseFuncCall()
        printInputs = ''
        cDataType = self.getCDatatype(self.inputOperands[0][1])
        outputsDeclarationStr = self.getOutputsDeclarationStr()
        outputResultsDeclarationStr = self.getOutputsDeclarationStr(withResult=True)
        outputStrWithReference = self.getOutputsStr(withReference=True)
        for (operand, dataType) in self.inputOperands:
            printInputs += f"\tprintf(\"Input {operand} = %d\\n\", ({self.getCDatatype(dataType)}) {operand});\n"

        testFileStr = f"""
// Automatically generated by bit-serial compiler
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <time.h>
#include "{self.moduleName}.bitwise.c"
#include "{goldenFunctionFilePath}"

bool runTest({inputsStrWithType}) {{
    // Calculate the expected result using the golden model
    {outputsDeclarationStr}
    {outputResultsDeclarationStr}
    {self.getGoldenFunctionName()}({inputsStr}, {outputStrWithReference});

    {bitwiseOpStr}

    {self.getVerificationCodeStr(cStyle=True)}

    return true;
}}

void main() {{
    printf("Info: Running test for bitwise IR of {self.moduleName}\\n");

    // Initialize random seed
    srand((unsigned int)time(NULL));

    // Run random tests
    int numTests = {self.numTests};  // Number of random test cases
    bool allPassed = true;
    for (int testNumber = 1; testNumber <= numTests; ++testNumber) {{
        {randGenStr}

        bool ok = runTest({inputsStr});
        allPassed &= ok;
        if (!ok) {{
            printf("Error: Test %d failed!\\n", testNumber);
        }} else {{
            printf("Info: Test %d passed!\\n", testNumber);
        }}
    }}
    if (allPassed) {{
        printf("Bitwise test: OK\\n");
    }} else {{
        printf("Bitwise test: NOT OK\\n");
    }}
}}
"""
        return testFileStr

