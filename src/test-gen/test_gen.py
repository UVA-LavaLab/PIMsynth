#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
File: test_gen.py
Description: Geneates test cases to validate the functionality of the output of the bit-serial compiler using PIMeval
Author: Mohammadhosein Gholamrezaei <uab9qt@virginia.edu>
Author: Deyuan Guo <guodeyuan@gmail.com> - Bit-wise C test code generation
Date: 2025-04-05
"""

import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from util import *

class TestGenerator:
    def __init__(self, moduleName, outputPath, numTests, pimMode = "digital", goldenFunctionPath=None):
        self.moduleName = moduleName
        self.outputPath = outputPath
        self.numTests = numTests
        self.pimMode = pimMode
        self.arch, self.numRegs, self.operator, self.dataType = self.splitModuleName(self.moduleName)
        self.goldenFunctionPath = goldenFunctionPath

    def splitModuleName(self, name):
        parts = name.split('__')
        if len(parts) != 4:
            raise ValueError(f"Invalid format: '{name}'. Expected format 'operation_datatype'.")
        arch, numRegs, pimMode = parts[:3]
        operator, dataType = parts[3].rsplit('_', 1)  # split by the last underscore
        return arch, numRegs, operator, dataType

    def generateMakeFile(self):
        makefileStr = f"""
# Automatically generated by bit-serial compiler

REPO_ROOT := $(shell git rev-parse --show-toplevel)
LIB_PIMEVAL_PATH := $(REPO_ROOT)/PIMeval-PIMbench/libpimeval

GCC = gcc
CXX = g++
CXXFLAGS = -I$(LIB_PIMEVAL_PATH)/include # Path to header files
LDFLAGS = -L$(LIB_PIMEVAL_PATH)/lib -l:libpimeval.a # Path to static library and linking

TARGET_PIM = {self.moduleName}.test.out
TARGET_BITWISE = {self.moduleName}.test_bitwise.out

all: $(TARGET_PIM) $(TARGET_BITWISE)

$(TARGET_PIM): {self.moduleName}.test.cpp
	$(CXX) $(CXXFLAGS) $< -o $@ $(LDFLAGS)

$(TARGET_BITWISE): {self.moduleName}.test_bitwise.c
	$(GCC) $< -o $@

clean:
	rm -f $(TARGET_PIM) $(TARGET_BITWISE)
"""
        return makefileStr

    def getBound(self):
        return 2 ** self.getCDataWidth()

    def getGoldenFunctionStatement(self, operator, dataType=None):
        opDict = {
            "add": f'a + b',
            "sub": f'a - b',
            "mul": f'a * b',
            "and": f'a & b',
            "or": f'a | b',
            "xor": f'a ^ b',
            "xnor": f'~(a ^ b)',
            "max": f'(a > b)?a:b',
            "min": f'(a < b)?a:b',
            "abs": f'(a > 0)?a:-a',
            "not": f'~a',
            "lt": f'(a < b)',
            "gt": f'(a > b)',
            "eq": f'(a == b)',
            "ne": f'(a != b)',
            "popcount": f'std::bitset<{dataType[3:]}>(a).count()' if dataType else None,
            "shift_l": f'a << b',
            "shift_r": f'a >> b',
        }

        expression = opDict.get(operator)
        if expression is None:
            return None
        return f"return ({expression}) % {self.getBound()};"

    def getCDatatype(self):
        lookupDict = {
            "int1" : "int8_t",
            "int2" : "int8_t",
            "int3" : "int8_t",
            "int4" : "int8_t",
            "int8" : "int8_t",
            "int16" : "int16_t",
            "int32" : "int32_t",
            "int64" : "int64_t",
            "uint8" : "uint8_t",
            "uint16" : "uint16_t",
            "uint32" : "uint32_t",
            "uint64" : "uint64_t",
        }
        return lookupDict[self.dataType]

    def getCDataWidth(self):
        lookupDict = {
            "int1" : 1,
            "int2" : 2,
            "int3" : 3,
            "int4" : 4,
            "int8" : 8,
            "int16" : 16,
            "int32" : 32,
            "int64" : 64,
            "uint8" : 8,
            "uint16" : 16,
            "uint32" : 32,
            "uint64" : 64,
        }
        return lookupDict[self.dataType]

    def getPimEvalDataType(self):
        lookupDict = {
            "int1" : "PIM_INT8",
            "int2" : "PIM_INT8",
            "int3" : "PIM_INT8",
            "int4" : "PIM_INT8",
            "int8" : "PIM_INT8",
            "int16" : "PIM_INT16",
            "int32" : "PIM_INT32",
            "int64" : "PIM_INT64",
            "uint8" : "PIM_UINT8",
            "uint16" : "PIM_UINT16",
            "uint32" : "PIM_UINT32",
            "uint64" : "PIM_UINT64",
        }
        return lookupDict[self.dataType]

    def getOperandsCount(self):
        oneOperand = ["not", "abs", "popcount"]
        twoOperand = ["add", "sub", "mul", "and", "or", "xor", "xnor", "mul", "min", "max", "lt", "gt", "eq", "ne", "shift_l", "shift_r"]

        if self.operator in oneOperand:
            return 1
        if self.operator in twoOperand:
            return 2
        raise Exception(f"Error: operator {self.operator} is not handled.")

    def getInputsList(self):
        if self.getOperandsCount() == 1: return ["a"]
        if self.getOperandsCount() == 2: return ["a", "b"]
        raise Exception(f"Error: number of input operands is more than 2 which is not handled.")

    def getPimObjList(self):
        lst = []
        for item in self.getInputsList():
            lst.append(item + "Pim")
        return lst

    def getInputsStr(self):
        returnStr = ""
        i = 0
        for inputStr in self.getInputsList():
            returnStr += f"{inputStr}"
            if (i != len(self.getInputsList()) - 1):
                returnStr += ", "
            i+= 1
        return returnStr

    def getPimObjsStr(self):
        returnStr = ""
        i = 0
        for inputStr in self.getInputsList():
            returnStr += f"{inputStr}Pim"
            if (i != len(self.getInputsList()) - 1):
                returnStr += ", "
            i+= 1
        return returnStr

    def getInputsStrWithType(self):
        returnStr = ""
        i = 0
        for inputStr in self.getInputsList():
            returnStr += f"{self.getCDatatype()} {inputStr}"
            if (i != len(self.getInputsList()) - 1):
                returnStr += ", "
            i+= 1
        return returnStr

    def getPimObjStrWithType(self):
        returnStr = ""
        i = 0
        for objStr in self.getPimObjList():
            returnStr += f"PimObjId {objStr}"
            if (i != len(self.getPimObjList()) - 1):
                returnStr += ", "
            i+= 1
        return returnStr

    def getGoldenFunctionName(self):
        return f"{self.moduleName}_golden"

    def generateGoldenFunctionFile(self):
        if self.goldenFunctionPath is None:
            functionName = self.getGoldenFunctionName()
            code = f"#ifndef {functionName.upper()}_H\n"
            code += f"#define {functionName.upper()}_H\n"
            signature = f"{self.getCDatatype()} {functionName}({self.getInputsStrWithType()})"
            testStatmentStr = self.getGoldenFunctionStatement(self.operator, self.dataType)
            if testStatmentStr is None:
                raise Exception("Error: The test generator does not support {self.operator} operator.")
            code += f"""
    {signature} {{
      {testStatmentStr}
    }}\n
    """
            code += "#endif\n\n"
        else:
            code = getContent(self.goldenModelHeaderFile)
        return code

    def getPimCopyHosttoDeviceStr(self):
        returnStr = ""
        for inputStr in self.getInputsList():
            returnStr += f"pimCopyHostToDevice(&{inputStr}, {inputStr}Pim);\n\t"
        return returnStr

    def getCoutStr(self):
        returnStr = ""
        i = 0
        for inputStr in self.getInputsList():
            returnStr += f"\"Input {inputStr} = \" << (int) {inputStr} << "
            if (i != len(self.getInputsList()) - 1):
                returnStr += "\", \" << "
            i+= 1
        return returnStr

    def getPimAllocStr(self):
        returnStr = ""
        firstObjStr = self.getPimObjList()[0]
        returnStr += f"PimObjId {firstObjStr} = pimAlloc(PIM_ALLOC_V, 1, {self.getPimEvalDataType()});\n\t"
        for objStr in self.getPimObjList()[1:]:
            returnStr += f"PimObjId {objStr} = pimAllocAssociated({firstObjStr}, {self.getPimEvalDataType()});\n\t"
        return returnStr

    def getRandGenStr(self, c_style = False):
        returnStr = ""
        randFunc = "rand()" if c_style else "std::rand()"
        for i, inputStr in enumerate(self.getInputsList()):
            if self.operator in ["shift_l", "shift_r"] and i == 1:
                bound = self.getCDataWidth()  # limit the shift amount to the data width
            else:
                bound = 2 ** self.getCDataWidth()
            returnStr += f"{self.getCDatatype()} {inputStr} = {randFunc} % {bound};\n\t\t"
        return returnStr

    def getPimFreeStr(self):
        returnStr = ""
        for objStr in self.getPimObjList():
            returnStr += f"pimFree({objStr});\n\t"
        return returnStr

    def resolveGoldenFunctionPath(self):
        goldenFunctionFilePath = f"{self.moduleName}.golden.hpp"
        if not self.goldenFunctionPath is None:
            goldenFunctionFilePath = self.goldenFunctionFilePath
        return goldenFunctionFilePath

    def generatCppTestFile(self):
        goldenFunctionFilePath = self.resolveGoldenFunctionPath()
        inputsStrWithType = self.getInputsStrWithType()
        pimObjStrWithType = self.getPimObjStrWithType()
        inputsStr = self.getInputsStr()
        pimCopyHostToDeviceStr = self.getPimCopyHosttoDeviceStr()

        pimObjsStr = self.getPimObjsStr()
        coutStr = self.getCoutStr()
        pimAllocStr = self.getPimAllocStr()
        randGenStr = self.getRandGenStr()
        pimFreeStr = self.getPimFreeStr()

        if self.pimMode == "digital":
            pimDevice = "PIM_DEVICE_BITSIMD_V"
        else:
            pimDevice = "PIM_DEVICE_SIMDRAM"
        testFileStr = f"""
// Automatically generated by bit-serial compiler
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <cstdint>
#include <bitset>
#include "{self.moduleName}.hpp"
#include "{goldenFunctionFilePath}"
#include "libpimeval.h"


bool runTest({inputsStrWithType}, {pimObjStrWithType}, PimObjId resultPim) {{
  // Calculate the expected result using the golden model
  int expectedResult = {self.getGoldenFunctionName()}({inputsStr});

  // Copy data to PIM device
  {pimCopyHostToDeviceStr}

  // Call the function under test
  {self.moduleName}({pimObjsStr}, resultPim);

  // Retrieve and verify the result from the PIM device
  {self.getCDatatype()} pimResult;
  pimCopyDeviceToHost(resultPim, &pimResult);

  // Verify the result
  if (pimResult != expectedResult) {{
      // Print all inputs and outputs if there is a mismatch
      std::cerr << {coutStr} std::endl;
      std::cerr << "  Expected result = " << (int) expectedResult << ", PIM result = " << (int) pimResult << std::endl;
      return false;
  }}
  return true;
}}

int main() {{
  // Initialize random seed
  std::srand(static_cast<unsigned int>(std::time(nullptr)));

  // Initialize PIM device
  PimStatus status = pimCreateDevice({pimDevice}, 1, 1, 2, 1024, 1024);
  if (status != PIM_OK) {{
      std::cerr << "Error: Failed to create PIM device with default config" << std::endl;
      return -1;
  }}

  // Allocate PIM objects for the 32-bit input/output ports with element size = 1
  {pimAllocStr}
  PimObjId resultPim = pimAllocAssociated(aPim, {self.getPimEvalDataType()});

  // Run random tests
  int numTests = {self.numTests};  // Number of random test cases
  bool allPassed = true;
  for (int testNumber = 1; testNumber <= numTests; ++testNumber) {{
      {randGenStr}

      pimResetStats();
      bool ok = runTest({inputsStr}, {pimObjsStr}, resultPim);
      allPassed &= ok;
      if (!ok) {{
          std::cerr << "Error: Test " << testNumber << " failed!" << std::endl;
      }} else {{
          std::cout << "Info: Test " << testNumber << " passed!" << std::endl;
      }}
  }}

  pimShowStats();
  if (allPassed) {{
      std::cout << "PIM test: ALL PASSED!" << std::endl;
  }} else {{
      std::cerr << "PIM test: SOME FAILED!" << std::endl;
  }}

  // Clean up and free allocated resources
  {pimFreeStr}
  pimFree(resultPim);
  pimDeleteDevice();

  return 0;
}}

"""

        return testFileStr

    def getBitwiseFuncCall(self):
        """ Call the bitwise function """
        dataWidth = self.getCDataWidth()
        funcCallStr = ''
        params = ''
        for input in self.getInputsList():
            funcCallStr += f"""
            int bit_{input}[{dataWidth}];
            for (int i = 0; i < {dataWidth}; i++) {{
                bit_{input}[i] = {input} & (1 << i) ? 1 : 0;
            }}
            """
            for i in range(dataWidth):
                params += f'bit_{input}+{i}, '

        funcCallStr += f'\tint bit_out[{dataWidth}];\n'
        for i in range(dataWidth):
            params += f'bit_out+{i}, '
        params = params[:-2] # remove last comma and space

        funcCallStr += f'\tfunc({params});'

        funcCallStr += f"""
            result = 0;
            for (int i = 0; i < {dataWidth}; i++) {{
                result |= bit_out[i] << i;
            }}
        """
        return funcCallStr

    def generatBitwiseTestFile(self):
        """ Generate test file for bitwise IR """
        goldenFunctionFilePath = self.resolveGoldenFunctionPath()
        inputsStrWithType = self.getInputsStrWithType()
        inputsStr = self.getInputsStr()
        randGenStr = self.getRandGenStr(True) # C style
        bitwiseOpStr = self.getBitwiseFuncCall()
        printInputs = ''
        cDataType = self.getCDatatype()
        for inputStr in self.getInputsList():
            printInputs += f"\tprintf(\"Input {inputStr} = %d\\n\", (int) {inputStr});\n"

        testFileStr = f"""
// Automatically generated by bit-serial compiler
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <time.h>
#include "{self.moduleName}.bitwise.c"
#include "{goldenFunctionFilePath}"

bool runTest({inputsStrWithType}) {{
    // Calculate the expected result using the golden model
    int result = 0;
    int expected = {self.getGoldenFunctionName()}({inputsStr});

    {bitwiseOpStr}

    // Verify the result
    if (({cDataType})result != ({cDataType})expected) {{
        // Print all inputs and outputs if there is a mismatch
        {printInputs}
        printf("expected = %d, result = %d\\n", expected, result);
        return false;
    }}
    return true;
}}

void main() {{
    printf("Info: Running test for bitwise IR of {self.moduleName}\\n");

    // Initialize random seed
    srand((unsigned int)time(NULL));

    // Run random tests
    int numTests = {self.numTests};  // Number of random test cases
    bool allPassed = true;
    for (int testNumber = 1; testNumber <= numTests; ++testNumber) {{
        {randGenStr}

        bool ok = runTest({inputsStr});
        allPassed &= ok;
        if (!ok) {{
            printf("Error: Test %d failed!\\n", testNumber);
        }} else {{
            printf("Info: Test %d passed!\\n", testNumber);
        }}
    }}
    if (allPassed) {{
        printf("Bitwise test: OK\\n");
    }} else {{
        printf("Bitwise test: NOT OK\\n");
    }}
}}
"""

        return testFileStr

