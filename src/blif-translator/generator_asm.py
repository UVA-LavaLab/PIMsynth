#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
File: generator_asm.py
Description: Generator for C with RISC-V inline assembly
Author: Mohammadhosein Gholamrezaei <uab9qt@virginia.edu> - BLIF-to-C parser generator code framework
Author: Deyuan Guo <guodeyuan@gmail.com> - Designed and implemented RISC-V inline assembly format
                                         - Support bus inputs and outputs
                                         - Support inline assembly for analog PIM
Date: 2024-09-17
"""


class GeneratorAsm():
    """ Generator for C with RISC-V inline assembly """

    def __init__(self, dag, num_regs, func_name, pim_mode):
        """ Init """
        self.dag = dag
        self.data_type = "int"
        self.num_regs = num_regs
        self.func_name = func_name
        self.pim_mode = pim_mode

    def sanitize_token(self, token):
        """ Sanitize token name to be used as a C variable name
            Bus name: a[0] -> a_0_
        """
        return self.dag.sanitize_name(token)

    def sanitize_token_list(self, token_list):
        """ Sanitize token names to be used as a C variable names
            Bus name: a[0] -> a_0_
        """
        return [self.dag.sanitize_name(token) for token in token_list]

    def generate_code(self):
        """ Generate C code """
        code = self.generate_header_files()
        code += self.generate_function_signature()
        code += self.generate_function_body()
        return code

    def generate_header_files(self):
        """ Generate header files """
        code = "// Auto Generated by Bit-Serial Compiler: C converted from BLIF\n\n"
        return code

    def generate_function_signature(self):
        """ Generate function signature """
        code = "void "
        code += self.func_name
        code += "(\n"
        code += self.generate_function_args()
        code += ")\n"
        return code

    def generate_function_args(self):
        """ Generate function args passed by pointers """
        inputs = self.sanitize_token_list(self.dag.get_in_ports())
        in_items = [f"{self.data_type} *{item}_pi" for item in inputs]
        outputs = self.sanitize_token_list(self.dag.get_out_ports())
        out_items = [f"{self.data_type} *{item}_po" for item in outputs]
        return f"\t{',\n\t'.join(in_items + out_items)}\n"

    def generate_function_body(self):
        """ Generate function body """
        code = "{\n"
        code += self.generate_temporary_variables()
        code += self.generate_temporary_variables_in()
        code += self.generate_temporary_variables_out()
        code += "\n"
        code += self.generate_all_asm_statements()
        code += "\n"
        code += self.generate_statements_output()
        code += "}\n"
        return code

    def generate_temporary_variables(self):
        """ Generate temporary variables for wires """
        wire_list = self.dag.get_wire_name_list()
        if len(wire_list) == 0:
            return ""
        variables = ', '.join(wire_list)
        return f"\t{self.data_type} {variables};\n"

    def generate_temporary_variables_in(self):
        """ Generate temp variables that dereference input pointers """
        inputs = self.sanitize_token_list(self.dag.get_in_ports())
        return f"\t{self.data_type} {', '.join([f'{item} = *{item}_pi' for item in inputs])};\n"

    def generate_temporary_variables_out(self):
        """ Generate temp variables for storing outputs """
        outputs = self.sanitize_token_list(self.dag.get_out_ports())
        return f"\t{self.data_type} {', '.join(outputs)};\n"

    def raise_exception(self, message):
        """ Helper function to raise an exception with a message """
        raise ValueError(message)

    def generate_clobber_list(self):
        """ Generate the RISC-V register clobbering list """
        # risc-v register: ra, a0-a7, s0-s11, t0-t6
        # ra: return address, a0-a7: argument registers, s0-s11: callee saved registers, t0-t6: temporary registers
        regs_special = ['"ra"']
        regs_args = [f'"a{i}"' for i in range(8)]
        regs_saved = [f'"s{i}"' for i in range(12)]
        regs_temp = [f'"t{i}"' for i in range(7)]
        # clobber list: use t0-t6 for 1-7 registers, use s0-s11 for 8-19 registers
        regs_temp_to_use = 0
        regs_saved_to_use = 0
        if self.num_regs > 7 and self.num_regs <= 19:
            regs_temp_to_use = 7
            regs_saved_to_use = self.num_regs - 7
        if self.num_regs <= 7:
            regs_temp_to_use = self.num_regs
        regs_to_clobber = regs_special + regs_args + regs_saved[regs_saved_to_use:] + regs_temp[regs_temp_to_use:]
        return ','.join(regs_to_clobber)

    def get_asm_instructions(self, gate_id, sn, clobber):
        """ Return a dictionary that maps logic gate names to assembly code generation functions """
        if self.pim_mode == "digital":
            return self.get_asm_instructions_digital(gate_id, sn, clobber)
        if self.pim_mode == "analog":
            return self.get_asm_instructions_analog(gate_id, sn, clobber)
        raise ValueError(f"Error: Unknown pim mode {self.pim_mode}")

    def get_asm_instructions_digital(self, gate_id, sn, clobber):
        """ Return a dictionary that maps logic gate names to assembly code generation functions for digital PIM """
        # =r: output register, r: input register
        # return a single line assembly code. Be careful with " and \\n
        gate = self.dag.graph.nodes[gate_id]
        gate_func = gate['gate_func']
        if gate_func in ['in_port', 'out_port']:
            return ""  # Skip input and output ports
        inputs = self.sanitize_token_list(gate['inputs'])
        outputs = self.sanitize_token_list(gate['outputs'])
        info = self.get_gate_func_encoding(gate_id)
        code = ''
        if gate_func == 'inv1':
            if len(outputs) == 1 and len(inputs) == 1:
                code += f'"#PIM_OP {sn} {info} %0 %1 \\n'
                code += ' not %0, %1'
                code += f'" : "=r" ({outputs[0]}) : "r" ({inputs[0]}) : {clobber}'
            else:
                self.raise_exception(f"Invalid inv1 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
        elif gate_func == 'and2':
            if len(outputs) == 1 and len(inputs) == 2:
                code += f'"#PIM_OP {sn} {info} %0 %1 %2 \\n'
                code += ' and %0, %1, %2'
                code += f'" : "=r" ({outputs[0]}) : "r" ({inputs[0]}), "r" ({inputs[1]}) : {clobber}'
            else:
                self.raise_exception(f"Invalid and2 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
        elif gate_func == 'nand2':
            if len(outputs) == 1 and len(inputs) == 2:
                code += f'"#PIM_OP {sn} {info} %0 %1 %2 \\n'
                code += ' and %0, %1, %2 \\n'
                code += ' not %0, %0'
                code += f'" : "=r" ({outputs[0]}) : "r" ({inputs[0]}), "r" ({inputs[1]}) : {clobber}'
            else:
                self.raise_exception(f"Invalid nand2 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
        elif gate_func == 'or2':
            if len(outputs) == 1 and len(inputs) == 2:
                code += f'"#PIM_OP {sn} {info} %0 %1 %2 \\n'
                code += ' or %0, %1, %2'
                code += f'" : "=r" ({outputs[0]}) : "r" ({inputs[0]}), "r" ({inputs[1]}) : {clobber}'
            else:
                self.raise_exception(f"Invalid or2 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
        elif gate_func == 'nor2':
            if len(outputs) == 1 and len(inputs) == 2:
                code += f'"#PIM_OP {sn} {info} %0 %1 %2 \\n'
                code += ' or %0, %1, %2 \\n'
                code += ' not %0, %0'
                code += f'" : "=r" ({outputs[0]}) : "r" ({inputs[0]}), "r" ({inputs[1]}) : {clobber}'
            else:
                self.raise_exception(f"Invalid nor2 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
        elif gate_func == 'xor2':
            if len(outputs) == 1 and len(inputs) == 2:
                code += f'"#PIM_OP {sn} {info} %0 %1 %2 \\n'
                code += ' xor %0, %1, %2'
                code += f'" : "=r" ({outputs[0]}) : "r" ({inputs[0]}), "r" ({inputs[1]}) : {clobber}'
            else:
                self.raise_exception(f"Invalid xor2 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
        elif gate_func == 'xnor2':
            if len(outputs) == 1 and len(inputs) == 2:
                code += f'"#PIM_OP {sn} {info} %0 %1 %2 \\n'
                code += ' xor %0, %1, %2 \\n'
                code += ' not %0, %0'
                code += f'" : "=r" ({outputs[0]}) : "r" ({inputs[0]}), "r" ({inputs[1]}) : {clobber}'
            else:
                self.raise_exception(f"Invalid xnor2 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
        elif gate_func == 'mux2':
            if len(outputs) == 1 and len(inputs) == 3:
                code += f'"#PIM_OP {sn} {info} %0 %1 %3 %2 \\n'
                code += ' not s1, %1 \\n'
                code += ' and s2, s1, %2 \\n'
                code += ' and s3, %1, %3 \\n'
                code += ' or %0, s2, s3'
                code += f'" : "=r" ({outputs[0]}) : "r" ({inputs[0]}), "r" ({inputs[1]}), "r" ({inputs[2]}) : {clobber}'
            else:
                self.raise_exception(f"Invalid mux2 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
        elif gate_func == 'maj3':
            if len(outputs) == 1 and len(inputs) == 3:
                code += f'"#PIM_OP {sn} {info} %0 %1 %2 %3 \\n'
                code += ' and s1, %1, %2 \\n'
                code += ' and s2, %2, %3 \\n'
                code += ' and s3, %1, %3 \\n'
                code += ' or s1, s1, s2 \\n'
                code += ' or %0, s1, s3'
                code += f'" : "=r" ({outputs[0]}) : "r" ({inputs[0]}), "r" ({inputs[1]}), "r" ({inputs[2]}) : {clobber}'
            else:
                self.raise_exception(f"Invalid maj3 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
        elif gate_func == 'zero':
            if len(outputs) == 1 and len(inputs) == 0:
                code += f'"#PIM_OP {sn} {info} %0 \\n'
                code += ' li %0, 0 \\n'
                code += ' mv %0, %0'
                code += f'" : "=r" ({outputs[0]}) : : {clobber}'
            else:
                self.raise_exception(f"Invalid zero operands: {len(outputs)} outputs and {len(inputs)} inputs.")
        elif gate_func == 'one':
            if len(outputs) == 1 and len(inputs) == 0:
                code += f'"#PIM_OP {sn} {info} %0 \\n'
                code += ' li %0, 0 \\n'
                code += ' not %0, %0'
                code += f'" : "=r" ({outputs[0]}) : : {clobber}'
            else:
                self.raise_exception(f"Invalid one operands: {len(outputs)} outputs and {len(inputs)} inputs.")
        else:
            self.raise_exception(f"Error: Unknown gate function {gate_func} for gate {gate_id}")
        return f'\tasm({code});\n'

    def get_asm_instructions_analog(self, gate_id, sn, clobber):
        """ Return a dictionary that maps logic gate names to assembly code generation functions for analog PIM """
        # return a single line assembly code. Be careful with " and \\n
        # r: input register
        # +r: both input and output
        # 0: input uses same register as output 0
        # =r: output register
        # =&r: output must be different from inputs using early clobber
        gate = self.dag.graph.nodes[gate_id]
        gate_func = gate['gate_func']
        if gate_func in ['in_port', 'out_port']:
            return ""  # Skip input and output ports
        inputs = self.sanitize_token_list(gate['inputs'])
        outputs = self.sanitize_token_list(gate['outputs'])
        info = self.get_gate_func_encoding(gate_id)
        code = ''
        if gate_func == 'copy':
            # Note: This is regular wire copy
            if len(outputs) == 1 and len(inputs) == 1:
                code += f'"#PIM_OP {sn} {info} %0 %1 \\n'
                code += ' mv %0, %1'
                code += f'" : "=r" ({outputs[0]}) : "r" ({inputs[0]}) : {clobber}'
            else:
                self.raise_exception(f"Invalid copy operands: {len(outputs)} outputs and {len(inputs)} inputs.")
        elif gate_func == 'copy_inout':
            # Note: copy_inout is used by wire copy inserter, supporting dependency chain while copying
            if len(outputs) == 1 and len(inputs) == 1:
                code += f'"#PIM_OP {sn} {info} %0 %1 \\n'
                code += ' mv %0, %1'
                code += f'" : "=r" ({outputs[0]}), "+r" ({inputs[0]}) : : {clobber}'
            else:
                self.raise_exception(f"Invalid copy_inout operands: {len(outputs)} outputs and {len(inputs)} inputs.")
        elif gate_func == 'inv1':
            # Note: Enforce inverter input/output to be different, to reduce the number of copies in ASM translator
            if len(outputs) == 1 and len(inputs) == 1:
                code += f'"#PIM_OP {sn} {info} %0 %1 \\n'
                code += ' not %0, %1'
                code += f'" : "=&r" ({outputs[0]}) : "r" ({inputs[0]}) : {clobber}'
            else:
                self.raise_exception(f"Invalid inv1 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
        elif gate_func == 'and2':
            if len(outputs) == 1 and len(inputs) == 2:
                code += f'"#PIM_OP {sn} {info} %0 %1 %2 \\n'
                code += ' and %0, %1, %2 \\n'
                code += ' mv %1, %0 \\n'
                code += ' mv %2, %0'
                code += f'" : "=&r" ({outputs[0]}), "+r" ({inputs[0]}), "+r" ({inputs[1]}) : : {clobber}'
            else:
                self.raise_exception(f"Invalid and2 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
        elif gate_func == 'or2':
            if len(outputs) == 1 and len(inputs) == 2:
                code += f'"#PIM_OP {sn} {info} %0 %1 %2 \\n'
                code += ' or %0, %1, %2 \\n'
                code += ' mv %1, %0 \\n'
                code += ' mv %2, %0'
                code += f'" : "=&r" ({outputs[0]}), "+r" ({inputs[0]}), "+r" ({inputs[1]}) : : {clobber}'
            else:
                self.raise_exception(f"Invalid or2 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
        elif gate_func == 'maj3':
            if len(outputs) == 1 and len(inputs) == 3:
                code += f'"#PIM_OP {sn} {info} %0 %1 %2 %3 \\n'
                code += ' and s1, %1, %2 \\n'
                code += ' and s2, %2, %3 \\n'
                code += ' and s3, %1, %3 \\n'
                code += ' or s1, s1, s2 \\n'
                code += ' or %0, s1, s3 \\n'
                code += ' mv %1, %0 \\n'
                code += ' mv %2, %0 \\n'
                code += ' mv %3, %0'
                code += f'" : "=&r" ({outputs[0]}), "+r" ({inputs[0]}), "+r" ({inputs[1]}), "+r" ({inputs[2]}) : : {clobber}'
            elif len(outputs) == 2 and len(inputs) == 3:
                code += f'"#PIM_OP {sn} {info} %0 %1 %2 %3 %4 \\n'
                code += ' and s1, %2, %3 \\n'
                code += ' and s2, %3, %4 \\n'
                code += ' and s3, %2, %4 \\n'
                code += ' or s1, s1, s2 \\n'
                code += ' or %0, s1, s3 \\n'
                code += ' mv %1, %0 \\n'
                code += ' mv %2, %0 \\n'
                code += ' mv %3, %0 \\n'
                code += ' mv %4, %0'
                code += f'" : "=&r" ({outputs[0]}), "=&r" ({outputs[1]}), "+r" ({inputs[0]}), "+r" ({inputs[1]}), "+r" ({inputs[2]}) : : {clobber}'
            elif len(outputs) == 3 and len(inputs) == 3:
                code += f'"#PIM_OP {sn} {info} %0 %1 %2 %3 %4 %5 \\n'
                code += ' and s1, %3, %4 \\n'
                code += ' and s2, %4, %5 \\n'
                code += ' and s3, %3, %5 \\n'
                code += ' or s1, s1, s2 \\n'
                code += ' or %0, s1, s3 \\n'
                code += ' mv %1, %0 \\n'
                code += ' mv %2, %0 \\n'
                code += ' mv %3, %0 \\n'
                code += ' mv %4, %0 \\n'
                code += ' mv %5, %0'
                code += f'" : "=&r" ({outputs[0]}), "=&r" ({outputs[1]}), "=&r" ({outputs[2]}), "+r" ({inputs[0]}), "+r" ({inputs[1]}), "+r" ({inputs[2]}) : : {clobber}'
            else:
                self.raise_exception(f"Invalid maj3 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
        elif gate_func == 'zero':
            if len(outputs) == 1 and len(inputs) == 0:
                code += f'"#PIM_OP {sn} {info} %0 \\n'
                code += ' li %0, 0 \\n'
                code += ' mv %0, %0'
                code += f'" : "=r" ({outputs[0]}) : : {clobber}'
            else:
                self.raise_exception(f"Invalid zero operands: {len(outputs)} outputs and {len(inputs)} inputs.")
        elif gate_func == 'one':
            if len(outputs) == 1 and len(inputs) == 0:
                code += f'"#PIM_OP {sn} {info} %0 \\n'
                code += ' li %0, 0 \\n'
                code += ' not %0, %0'
                code += f'" : "=r" ({outputs[0]}) : : {clobber}'
            else:
                self.raise_exception(f"Invalid one operands: {len(outputs)} outputs and {len(inputs)} inputs.")
        else:
            self.raise_exception(f"Error: Unknown gate function {gate_func} for gate {gate_id}")
        return f'\tasm({code});\n'

    def get_inv(self, gate_id, in_idx):
        """ Check if an input pin index is inverted for a given gate ID """
        is_inv_input = self.dag.graph.nodes[gate_id]['inputs'][in_idx] in self.dag.graph.nodes[gate_id]['inverted']
        return is_inv_input

    def get_gate_func_encoding(self, gate_id):
        """ Get gate_func encoding for passing information to ASM translator """
        gate = self.dag.graph.nodes[gate_id]
        info = f" {gate['gate_func']}"

        # Append input inversion information
        inv_str = ''
        for i, _ in enumerate(gate['inputs']):
            inv_str += '1' if self.get_inv(gate_id, i) else '0'
        if '1' in inv_str:
            info += f"__n{inv_str}"

        return info

    def generate_single_asm_statement(self, gate_id, sn, clobber):
        """ Generate a single assembly statement based on the logic gate type """
        # Pass information from BLIF translator to ASM translator
        # Format: #PIM_OP <serial-number> <gate_func> operands
        return self.get_asm_instructions(gate_id, sn, clobber)

    def generate_all_asm_statements(self):
        """ Generate C asm statement sequence """
        # Generate the clobber list and assembly instruction mappings
        clobber = self.generate_clobber_list()

        # RISC-V inline assembly
        code = '\tasm("#PIM_OP BEGIN ##########");\n'

        # Generate assembly statements for each item in the statement list
        for i, gate_id in enumerate(self.dag.get_topo_sorted_gate_id_list()):
            code += self.generate_single_asm_statement(gate_id, i, clobber)

        code += '\tasm("#PIM_OP END ##########");\n'
        return code

    def generate_statements_output(self):
        """ Generate statements to store output temp vars to pointers """
        code = ""
        outputs = [port.replace("[", "_").replace("]", "_") for port in self.dag.get_out_ports()]
        for port in outputs:
            code += "\t*" + port + '_po = ' + port + ";\n"
        return code
