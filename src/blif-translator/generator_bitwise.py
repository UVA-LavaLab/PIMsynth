#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
File: generator_bitwise.py
Description: C code generator using bit-wise operations
Author: Mohammadhosein Gholamrezaei <uab9qt@virginia.edu> - BLIF-to-C parser generator code framework
Author: Deyuan Guo <guodeyuan@gmail.com> - Bit-wise C code generation for digital and analog PIM
Date: 2025-04-20
"""

class GeneratorBitwise():
    """ Bit-wise C code generator class for PIM architectures """

    def __init__(self, dag, num_regs, func_name, pim_mode):
        """ Init """
        self.dag = dag
        self.data_type = "int"
        self.num_regs = num_regs
        self.func_name = func_name
        self.pim_mode = pim_mode

    def sanitize_token(self, token):
        """ Sanitize token name to be used as a C variable name
            Bus name: a[0] -> a_0_
        """
        return self.dag.sanitize_name(token)

    def sanitize_token_list(self, token_list):
        """ Sanitize token names to be used as a C variable names
            Bus name: a[0] -> a_0_
        """
        return [self.dag.sanitize_name(token) for token in token_list]

    def generate_code(self):
        """ Generate C code """
        code = self.generate_header_files()
        code += self.generate_function_signature()
        code += self.generate_function_body()
        return code

    def generate_header_files(self):
        """ Generate header files """
        code = "// Auto Generated by Bit-Serial Compiler: Bit-wise C converted from BLIF\n\n"
        return code

    def generate_function_signature(self):
        """ Generate function signature """
        code = "void "
        code += self.func_name
        code += "(\n"
        code += self.generate_function_args()
        code += ")\n"
        return code

    def generate_function_args(self):
        """ Generate function args passed by pointers """
        inputs = self.sanitize_token_list(self.dag.get_in_ports())
        in_items = [f"{self.data_type} *{item}_pi" for item in inputs]
        outputs = self.sanitize_token_list(self.dag.get_out_ports())
        out_items = [f"{self.data_type} *{item}_po" for item in outputs]
        return f"\t{',\n\t'.join(in_items + out_items)}\n"

    def generate_function_body(self):
        """ Generate function body """
        code = "{\n"
        code += self.generate_temporary_variables()
        code += self.generate_temporary_variables_in()
        code += self.generate_temporary_variables_out()
        code += "\n"
        code += self.generate_all_bitwise_statements()
        code += "\n"
        code += self.generate_statements_output()
        code += "}\n"
        return code

    def generate_temporary_variables(self):
        """ Generate temporary variables for wires """
        wire_list = self.dag.get_wire_name_list()
        if len(wire_list) == 0:
            return ""
        variables = ', '.join(wire_list)
        return f"\t{self.data_type} {variables};\n"

    def generate_temporary_variables_in(self):
        """ Generate temp variables that dereference input pointers """
        inputs = self.sanitize_token_list(self.dag.get_in_ports())
        return f"\t{self.data_type} {', '.join([f'{item} = *{item}_pi' for item in inputs])};\n"

    def generate_temporary_variables_out(self):
        """ Generate temp variables for storing outputs """
        outputs = self.sanitize_token_list(self.dag.get_out_ports())
        return f"\t{self.data_type} {', '.join(outputs)};\n"

    def raise_exception(self, message):
        """ Helper function to raise an exception with a message """
        raise ValueError(message)

    def get_bitwise_instructions(self):
        """ Return a dictionary that maps logic gate names to bit-wise code generation functions """
        if self.pim_mode == "digital":
            return self.get_bitwise_instructions_digital()
        if self.pim_mode == "analog":
            return self.get_bitwise_instructions_analog()
        raise ValueError(f"Error: Unknown pim mode {self.pim_mode}")

    def get_bitwise_instructions_digital(self):
        """ Return a dictionary that maps logic gate names to bit-wise code generation functions for digital PIM """
        # Note: Use ! instead of ~ for bitwise NOT to make sure result is 0 or 1
        return {
            "inv1": lambda outputs, inputs, info: (
                f'\t// PIM_OP {info} %0 %1 \n'
                f'\t{outputs[0]} = !{inputs[0]};\n'
                if len(outputs) == 1 and len(inputs) == 1 else
                self.raise_exception(f"Invalid inv1 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
            ),
            "and2": lambda outputs, inputs, info: (
                f'\t// PIM_OP {info} %0 %1 %2 \n'
                f'\t{outputs[0]} = {inputs[0]} & {inputs[1]};\n'
                if len(outputs) == 1 and len(inputs) == 2 else
                self.raise_exception(f"Invalid and2 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
            ),
            "nand2": lambda outputs, inputs, info: (
                f'\t// PIM_OP {info} %0 %1 %2 \n'
                f'\t{outputs[0]} = !({inputs[0]} & {inputs[1]});\n'
                if len(outputs) == 1 and len(inputs) == 2 else
                self.raise_exception(f"Invalid nand2 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
            ),
            "or2": lambda outputs, inputs, info: (
                f'\t// PIM_OP {info} %0 %1 %2 \n'
                f'\t{outputs[0]} = {inputs[0]} | {inputs[1]};\n'
                if len(outputs) == 1 and len(inputs) == 2 else
                self.raise_exception(f"Invalid or2 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
            ),
            "nor2": lambda outputs, inputs, info: (
                f'\t// PIM_OP {info} %0 %1 %2 \n'
                f'\t{outputs[0]} = !({inputs[0]} | {inputs[1]});\n'
                if len(outputs) == 1 and len(inputs) == 2 else
                self.raise_exception(f"Invalid nor2 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
            ),
            "xor2": lambda outputs, inputs, info: (
                f'\t// PIM_OP {info} %0 %1 %2 \n'
                f'\t{outputs[0]} = {inputs[0]} ^ {inputs[1]};\n'
                if len(outputs) == 1 and len(inputs) == 2 else
                self.raise_exception(f"Invalid xor2 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
            ),
            "xnor2": lambda outputs, inputs, info: (
                f'\t// PIM_OP {info} %0 %1 %2 \n'
                f'\t{outputs[0]} = !({inputs[0]} ^ {inputs[1]});\n'
                if len(outputs) == 1 and len(inputs) == 2 else
                self.raise_exception(f"Invalid xnor2 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
            ),
            "mux2": lambda outputs, inputs, info: ( # %0 = %1 ? %3 : %2
                f'\t// PIM_OP {info} %0 %1 %2 \n'
                f'\t{outputs[0]} = {inputs[0]} ? {inputs[2]} : {inputs[1]};\n'
                if len(outputs) == 1 and len(inputs) == 3 else
                self.raise_exception(f"Invalid mux2 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
            ),
            "maj3": lambda outputs, inputs, info: (
                f'\t// PIM_OP {info} %0 %1 %2 %3 \n'
                f'\t{outputs[0]} = ({inputs[0]} & {inputs[1]}) | ({inputs[0]} & {inputs[2]}) | ({inputs[1]} & {inputs[2]});\n'
                if len(outputs) == 1 and len(inputs) == 3 else
                self.raise_exception(f"Invalid maj3 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
            ),
            "zero": lambda outputs, inputs, info: (
                f'\t// PIM_OP {info} %0 \n'
                f'\t{outputs[0]} = 0;\n'
                if len(outputs) == 1 and len(inputs) == 0 else
                self.raise_exception(f"Invalid zero operands: {len(outputs)} outputs and {len(inputs)} inputs.")
            ),
            "one": lambda outputs, inputs, info: (
                f'\t// PIM_OP {info} %0 \n'
                f'\t{outputs[0]} = 1;\n'
                if len(outputs) == 1 and len(inputs) == 0 else
                self.raise_exception(f"Invalid one operands: {len(outputs)} outputs and {len(inputs)} inputs.")
            ),
        }

    def get_bitwise_instructions_analog(self):
        """ Return a dictionary that maps logic gate names to bit-wise code generation functions for analog PIM """
        # Note: Use ! instead of ~ for bitwise NOT to make sure result is 0 or 1
        return {
            "copy": lambda outputs, inputs, info: (
                f'\t// PIM_OP {info} %0 %1 \n'
                f'\t{outputs[0]} = {inputs[0]};\n'
                if len(outputs) == 1 and len(inputs) == 1 else
                self.raise_exception(f"Invalid copy operands: {len(outputs)} outputs and {len(inputs)} inputs.")
            ),
            "copy_inout": lambda outputs, inputs, info: (
                f'\t// PIM_OP {info} %0 %1 \n'
                f'\t{outputs[0]} = {inputs[0]};\n'
                if len(outputs) == 1 and len(inputs) == 1 else
                self.raise_exception(f"Invalid copy_inout operands: {len(outputs)} outputs and {len(inputs)} inputs.")
            ),
            "inv1": lambda outputs, inputs, info: (
                f'\t// PIM_OP {info} %0 %1 \n'
                f'\t{outputs[0]} = !{inputs[0]};\n'
                if len(outputs) == 1 and len(inputs) == 1 else
                self.raise_exception(f"Invalid inv1 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
            ),
            "and2": lambda outputs, inputs, info: (
                f'\t// PIM_OP {info} %0 %1 %2 \n'
                f'\t{outputs[0]} = {inputs[0]} = {inputs[1]} = {inputs[0]} & {inputs[1]};\n'
                if len(outputs) == 1 and len(inputs) == 2 else
                self.raise_exception(f"Invalid and2 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
            ),
            "or2": lambda outputs, inputs, info: (
                f'\t// PIM_OP {info} %0 %1 %2 \n'
                f'\t{outputs[0]} = {inputs[0]} = {inputs[1]} = {inputs[0]} | {inputs[1]};\n'
                if len(outputs) == 1 and len(inputs) == 2 else
                self.raise_exception(f"Invalid or2 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
            ),
            "maj3": lambda outputs, inputs, info: (
                f'\t// PIM_OP {info} %0 %1 %2 %3 \n'
                f'\t{outputs[0]} = {inputs[0]} = {inputs[1]} = {inputs[2]} = ({inputs[0]} & {inputs[1]}) | ({inputs[0]} & {inputs[2]}) | ({inputs[1]} & {inputs[2]});\n'
                if len(outputs) == 1 and len(inputs) == 3 else
                self.raise_exception(f"Invalid maj3 operands: {len(outputs)} outputs and {len(inputs)} inputs.")
            ),
            "zero": lambda outputs, inputs, info: (
                f'\t// PIM_OP {info} %0 \n'
                f'\t{outputs[0]} = 0;\n'
                if len(outputs) == 1 and len(inputs) == 0 else
                self.raise_exception(f"Invalid zero operands: {len(outputs)} outputs and {len(inputs)} inputs.")
            ),
            "one": lambda outputs, inputs, info: (
                f'\t// PIM_OP {info} %0 \n'
                f'\t{outputs[0]} = 1;\n'
                if len(outputs) == 1 and len(inputs) == 0 else
                self.raise_exception(f"Invalid one operands: {len(outputs)} outputs and {len(inputs)} inputs.")
            ),
        }

    def generate_single_bitwise_statement(self, gate_id, bitwise_instructions, info):
        """ Generate a single bit-wise statement based on the logic gate type """
        gate = self.dag.graph.nodes[gate_id]
        if gate['gate_func'] in ['in_port', 'out_port']:
            # Skip input and output ports
            return ""
        inputs = self.sanitize_token_list(gate['inputs'])
        outputs = self.sanitize_token_list(gate['outputs'])

        gate_func = gate['gate_func']
        # Show information in bitwise code to align with ASM generation
        # Format: // PIM_OP <serial-number> <gate_func> operands
        info += f" {gate_func}"
        if gate_func in bitwise_instructions:
            bitwise_func = bitwise_instructions[gate_func]
            return bitwise_func(outputs, inputs, info)

        raise ValueError(f"Error: Unhandled gate type {gate_func} for gate ID {gate_id}.")

    def generate_all_bitwise_statements(self):
        """ Generate C bit-wise statement sequence """
        bitwise_instructions = self.get_bitwise_instructions()

        code = '\t// PIM_OP BEGIN ##########\n'

        for i, gate_id in enumerate(self.dag.get_topo_sorted_gate_id_list()):
            info = str(i)
            code += self.generate_single_bitwise_statement(gate_id, bitwise_instructions, info)

        code += '\t// PIM_OP END ##########\n'
        return code

    def generate_statements_output(self):
        """ Generate statements to store output temp vars to pointers """
        code = ""
        outputs = [item.replace("[", "_").replace("]", "_") for item in self.dag.get_out_ports()]
        for item in outputs:
            code += "\t*" + item + '_po = ' + item + ";\n"
        return code
