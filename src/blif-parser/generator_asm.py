#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
File: generator_asm.py
Description: Generator for C with RISC-V inline assembly
Author: Mohammadhosein Gholamrezaei <uab9qt@virginia.edu> - BLIF-to-C parser generator code framework
Author: Deyuan Guo <guodeyuan@gmail.com> - Designed and implemented RISC-V inline assembly format
                                         - Support bus inputs and outputs
                                         - Support inline assembly for analog PIM
Date: 2024-09-17
"""

class GeneratorAsm():
    def __init__(self, parser, num_regs, func_name, pim_mode):
        """ Init """
        self.parser = parser
        self.dataType = "int"
        self.num_regs = num_regs
        self.func_name = func_name
        self.pim_mode = pim_mode

    def sanitizeToken(self, token):
        """ Sanitize token name to be used as a C variable name
            Bus name: a[0] -> a_0_
        """
        return token.replace("[", "_").replace("]", "_")

    def sanitizeTokenList(self, token_list):
        """ Sanitize token names to be used as a C variable names
            Bus name: a[0] -> a_0_
        """
        return [token.replace("[", "_").replace("]", "_") for token in token_list]

    def generateCode(self):
        """ Generate C code """
        code = self.generateHeaderFiles()
        code += self.generateFunctionSignature()
        code += self.generateFunctionBody()
        return code

    def generateHeaderFiles(self):
        """ Generate header files """
        code = "// Auto Generated by Bit-Serial Compiler: C converted from BLIF\n\n"
        return code

    def generateFunctionSignature(self):
        """ Generate function signature """
        code = "void "
        code += self.func_name
        code += "(\n"
        code += self.generateFunctionArgs()
        code += ")\n"
        return code

    def generateFunctionArgs(self):
        """ Generate function args passed by pointers """
        inputs = self.sanitizeTokenList(self.parser.inputsList)
        in_items = [f"{self.dataType} *{item}_pi" for item in inputs]
        outputs = self.sanitizeTokenList(self.parser.outputsList)
        out_items = [f"{self.dataType} *{item}_po" for item in outputs]
        return f"\t{',\n\t'.join(in_items + out_items)}\n"

    def generateFunctionBody(self):
        """ Generate function body """
        code = "{\n"
        code += self.generateTemporaryVariables()
        code += self.generateTemporaryVariablesIn();
        code += self.generateTemporaryVariablesOut();
        code += "\n"
        code += self.generateAllAsmStatements()
        code += "\n"
        code += self.generateStatementsOutput()
        code += "}\n"
        return code

    def generateTemporaryVariables(self):
        if len(self.parser.wireList) == 0:
            return ""
        variables = ', '.join(self.parser.wireList)
        return f"\t{self.dataType} {variables};\n"

    def generateTemporaryVariablesIn(self):
        """ Generate temp variables that dereference input pointers """
        return f"\t{self.dataType} {', '.join([f'{item} = *{item}_pi' for item in self.sanitizeTokenList(self.parser.inputsList)])};\n"

    def generateTemporaryVariablesOut(self):
        """ Generate temp variables for storing outputs """
        outputs = self.sanitizeTokenList(self.parser.outputsList)
        return f"\t{self.dataType} {', '.join(outputs)};\n"

    def generateClobberList(self):
        """ Generate the RISC-V register clobbering list """
        # risc-v register: ra, a0-a7, s0-s11, t0-t6
        # ra: return address, a0-a7: argument registers, s0-s11: callee saved registers, t0-t6: temporary registers
        regs_special = ['"ra"']
        regs_args = [f'"a{i}"' for i in range(8)]
        regs_saved = [f'"s{i}"' for i in range(12)]
        regs_temp = [f'"t{i}"' for i in range(7)]
        # clobber list: use t0-t6 for 1-7 registers, use s0-s11 for 8-19 registers
        regs_temp_to_use = 0
        regs_saved_to_use = 0
        if self.num_regs > 7 and self.num_regs <= 19:
            regs_temp_to_use = 7
            regs_saved_to_use = self.num_regs - 7
        if self.num_regs <= 7:
            regs_temp_to_use = self.num_regs
        regs_to_clobber = regs_special + regs_args + regs_saved[regs_saved_to_use:] + regs_temp[regs_temp_to_use:]
        return ','.join(regs_to_clobber)

    def getAsmInstructions(self, clobber):
        """ Return a dictionary that maps logic gate names to assembly code generation functions """
        if self.pim_mode == "digital":
            return self.getAsmInstructionsDigital(clobber)
        elif self.pim_mode == "analog":
            return self.getAsmInstructionsAnalog(clobber)
        else:
            raise Exception(f"Error: Unknown pim mode {self.pim_mode}")

    def getAsmInstructionsDigital(self, clobber):
        """ Return a dictionary that maps logic gate names to assembly code generation functions for digital PIM """
        # =r: output register, r: input register
        # return a single line assembly code. Be careful with " and \\n
        return {
            "inv1": lambda output, inputs: (
                f'"#PIM_OP: inv1 %1 -> %0 \\n'
                f' not %0, %1'
                f'" : "=r" ({output}) : "r" ({inputs[0]}) : {clobber}'
            ),
            "and2": lambda output, inputs: (
                f'"#PIM_OP: and2 %1, %2 -> %0 \\n'
                f' and %0, %1, %2'
                f'" : "=r" ({output}) : "r" ({inputs[0]}), "r" ({inputs[1]}) : {clobber}'
            ),
            "nand2": lambda output, inputs: (
                f'"#PIM_OP: nand2 %1, %2 -> %0 \\n'
                f' and %0, %1, %2 \\n'
                f' not %0, %0'
                f'" : "=r" ({output}) : "r" ({inputs[0]}), "r" ({inputs[1]}) : {clobber}'
            ),
            "or2": lambda output, inputs: (
                f'"#PIM_OP: or2 %1, %2 -> %0 \\n'
                f' or %0, %1, %2'
                f'" : "=r" ({output}) : "r" ({inputs[0]}), "r" ({inputs[1]}) : {clobber}'
            ),
            "nor2": lambda output, inputs: (
                f'"#PIM_OP: nor2 %1, %2 -> %0 \\n'
                f' or %0, %1, %2 \\n'
                f' not %0, %0'
                f'" : "=r" ({output}) : "r" ({inputs[0]}), "r" ({inputs[1]}) : {clobber}'
            ),
            "xor2": lambda output, inputs: (
                f'"#PIM_OP: xor2 %1, %2 -> %0\\n'
                f' xor %0, %1, %2'
                f'" : "=r" ({output}) : "r" ({inputs[0]}), "r" ({inputs[1]}) : {clobber}'
            ),
            "xnor2": lambda output, inputs: (
                f'"#PIM_OP: xnor2 %1, %2 -> %0 \\n'
                f' xor %0, %1, %2 \\n'
                f' not %0, %0'
                f'" : "=r" ({output}) : "r" ({inputs[0]}), "r" ({inputs[1]}) : {clobber}'
            ),
            "mux2": lambda output, inputs: ( # %0 = %1 ? %3 : %2
                f'"#PIM_OP: mux2 %1, %2, %3 -> %0 \\n'
                f' not s1, %1 \\n'
                f' and s2, s1, %2 \\n'
                f' and s3, %1, %3 \\n'
                f' or %0, s2, s3'
                f'" : "=r" ({output}) : "r" ({inputs[0]}), "r" ({inputs[1]}), "r" ({inputs[2]}) : {clobber}'
            ),
            "maj3": lambda output, inputs: (
                f'"#PIM_OP: maj3 %1, %2, %3 -> %0 \\n'
                f' and s1, %1, %2 \\n'
                f' and s2, %2, %3 \\n'
                f' and s3, %1, %3 \\n'
                f' or s1, s1, s2 \\n'
                f' or %0, s1, s3'
                f'" : "=r" ({output}) : "r" ({inputs[0]}), "r" ({inputs[1]}), "r" ({inputs[2]}) : {clobber}'
            ),
            "zero": lambda output, inputs: (
                f'"#PIM_OP: zero -> %0 \\n'
                f' xor %0, %0, %0'
                f'" : "=r" ({output}) : "r" ({output}) : {clobber}'
            ),
            "one": lambda output, inputs: (
                f'"#PIM_OP: one -> %0 \\n'
                f' xor %0, %0, %0 \\n'
                f' not %0, %0'
                f'" : "=r" ({output}) : "r" ({output}) : {clobber}'
            ),
        }

    def getAsmInstructionsAnalog(self, clobber):
        """ Return a dictionary that maps logic gate names to assembly code generation functions for analog PIM """
        # =r: output register, r: input register
        # return a single line assembly code. Be careful with " and \\n
        return {
            "copy": lambda output, inputs: (
                f'"#PIM_OP: copy1 %1 -> %0 \\n'
                f' addi %0, %1, 0'
                f'" : "=r" ({output}) : "r" ({inputs[0]}) : {clobber}'
            ),
            "inv1": lambda output, inputs: (
                f'"#PIM_OP: inv1 %1 -> %0 \\n'
                f' not %0, %1'
                f'" : "=r" ({output}) : "r" ({inputs[0]}) : {clobber}'
            ),
            "and2": lambda output, inputs: (
                f'"#PIM_OP: and2 %1, %2 -> %0 \\n'
                f' and %0, %1, %2'
                f'" : "=r" ({output}) : "r" ({inputs[0]}), "r" ({inputs[1]}) : {clobber}'
            ),
            "maj3": lambda output, inputs: (
                f'"#PIM_OP: maj3 %1, %2, %3 -> %0 \\n'
                f' and s1, %1, %2 \\n'
                f' and s2, %2, %3 \\n'
                f' and s3, %1, %3 \\n'
                f' or s1, s1, s2 \\n'
                f' or %0, s1, s3'
                f'" : "=r" ({output}) : "r" ({inputs[0]}), "r" ({inputs[1]}), "r" ({inputs[2]}) : {clobber}'
            ),
            "zero": lambda output, inputs: (
                f'"#PIM_OP: zero -> %0 \\n'
                f' xor %0, %0, %0'
                f'" : "=r" ({output}) : "r" ({output}) : {clobber}'
            ),
            "one": lambda output, inputs: (
                f'"#PIM_OP: one -> %0 \\n'
                f' xor %0, %0, %0 \\n'
                f' not %0, %0'
                f'" : "=r" ({output}) : "r" ({output}) : {clobber}'
            ),
        }

    def generateSingleAsmStatement(self, item, asm_instructions):
        """ Generate a single assembly statement based on the logic gate type """
        inputs = self.sanitizeTokenList(item.inputs)
        output = self.sanitizeToken(item.outputs[0])

        for key, asm_func in asm_instructions.items():
            if item.type.startswith(key):
                return f'\tasm({asm_func(output, inputs)});\n'

        raise Exception(f"Error: Unhandled gate type {item.type}")

    def generateAllAsmStatements(self):
        """ Generate C asm statement sequence """
        # Generate the clobber list and assembly instruction mappings
        clobber = self.generateClobberList()
        asm_instructions = self.getAsmInstructions(clobber)

        # RISC-V inline assembly
        code = '\tasm("########## BEGIN ##########");\n'

        # Generate assembly statements for each item in the statement list
        for gate in self.parser.gatesList:
            code += self.generateSingleAsmStatement(gate, asm_instructions)

        code += '\tasm("########## END ##########");\n'
        return code

    def generateStatementsOutput(self):
        """ Generate statements to store output temp vars to pointers """
        code = ""
        outputs = [item.replace("[", "_").replace("]", "_") for item in self.parser.outputsList]
        for item in outputs:
            code += "\t*" + item + '_po = ' + item + ";\n"
        return code

