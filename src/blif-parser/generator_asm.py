#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
File: generator_asm.py
Description: Generator for C with RISC-V inline assembly
Author: Mohammadhosein Gholamrezaei <uab9qt@virginia.edu> - BLIF-to-C parser generator code framework
Author: Deyuan Guo <guodeyuan@gmail.com> - Designed and implemented RISC-V inline assembly format
                                         - Support bus inputs and outputs
Date: 2024-09-17
"""

class GeneratorAsm():
    def __init__(self, parser, num_regs, func_name):
        """ Init """
        self.parser = parser
        self.dataType = "int"
        self.num_regs = num_regs
        self.func_name = func_name

    def sanitize_token(self, token):
        """ Sanitize token name to be used as a C variable name
            Bus name: a[0] -> a_0_
        """
        return token.replace("[", "_").replace("]", "_")

    def sanitize_token_list(self, token_list):
        """ Sanitize token names to be used as a C variable names
            Bus name: a[0] -> a_0_
        """
        return [token.replace("[", "_").replace("]", "_") for token in token_list]

    def generateCode(self):
        """ Generate C code """
        code = self.generateHeaderFiles()
        code += self.generateFunctionSignature()
        code += self.generateFunctionBody()
        return code

    def generateHeaderFiles(self):
        """ Generate header files """
        code = "// Auto Generated by Bit-Serial Compiler: C converted from BLIF\n\n"
        return code

    def generateFunctionSignature(self):
        """ Generate function signature """
        code = "void "
        code += self.func_name
        code += "(\n"
        code += self.generateFunctionArgs()
        code += ")\n"
        return code

    def generateFunctionArgs(self):
        """ Generate function args passed by pointers """
        items = []
        inputs = self.sanitize_token_list(self.parser.inputsList)
        for item in inputs:
            items.append(self.dataType + " *" + item + "_p")
        outputs = self.sanitize_token_list(self.parser.outputsList)
        for item in outputs:
            items.append(self.dataType + " *" + item + "_p")
        code = "\t" + ",\n\t".join(items) + '\n'
        return code

    def generateFunctionBody(self):
        """ Generate function body """
        code = "{\n"
        code += self.generateTemporaryVariables()
        code += self.generateTemporaryVariablesIn();
        code += self.generateTemporaryVariablesOut();
        code += "\n"
        code += self.generateStatementsAsm()
        code += "\n"
        code += self.generateStatementsOutput()
        code += "}\n"
        return code

    def generateTemporaryVariables(self):
        """ Generate temp variables representing wires """
        items = []
        for item in self.parser.wireList:
            items.append(item)
        code = "\t" + self.dataType + " " + ", ".join(items) + ";\n"
        return code

    def generateTemporaryVariablesIn(self):
        """ Generate temp variables that dereference input pointers """
        items = []
        inputs = self.sanitize_token_list(self.parser.inputsList)
        for item in inputs:
            items.append(item + "=*" + item + "_p")
        code = "\t" + self.dataType + " " + ", ".join(items) + ";\n"
        return code

    def generateTemporaryVariablesOut(self):
        """ Generate temp variables for storing outputs """
        items = []
        outputs = self.sanitize_token_list(self.parser.outputsList)
        for item in outputs:
            items.append(item)
        code = "\t" + self.dataType + " " + ", ".join(items) + ";\n"
        return code

    def generateStatementsAsm(self):
        """ Generate C asm statement sequence """
        # Deterime RISC-V register clobbering list
        regs = ['"ra"']
        for i in range(8):
            regs.append('"a' + str(i) + '"')
        for i in range(12):
            regs.append('"s' + str(i) + '"')
        for i in range(self.num_regs, 7):
            regs.append('"t' + str(i) + '"')
        clobber = ','.join(regs)

        # RISC-V inline assembly
        # Map each logic gate to an asm statement, which may include multiple instructions
        # Define inputs, outputs, and register clobbering
        code = '\tasm("########## BEGIN ##########");\n'
        for item in self.parser.statementList:
            inputs = self.sanitize_token_list(item.inputList)
            output = self.sanitize_token(item.output)
            if item.name.startswith("inv1"):
                code += ('\tasm("not %%0, %%1" : "=r" (%s) : "r" (%s) : %s );\n'
                        % (output, inputs[0], clobber))
            elif item.name.startswith("and2"):
                code += ('\tasm("and %%0, %%1, %%2" : "=r" (%s) : "r" (%s), "r" (%s) : %s );\n'
                        % (output, inputs[0], inputs[1], clobber))
            elif item.name.startswith("nand2"):
                code += ('\tasm("and %%0, %%1, %%2\\nnot %%0, %%0" : "=r" (%s) : "r" (%s), "r" (%s) : %s );\n'
                        % (output, inputs[0], inputs[1], clobber))
            elif item.name.startswith("or2"):
                code += ('\tasm("or %%0, %%1, %%2" : "=r" (%s) : "r" (%s), "r" (%s) : %s );\n'
                        % (output, inputs[0], inputs[1], clobber))
            elif item.name.startswith("nor2"):
                code += ('\tasm("or %%0, %%1, %%2\\nnot %%0, %%0" : "=r" (%s) : "r" (%s), "r" (%s) : %s );\n'
                        % (output, inputs[0], inputs[1], clobber))
            elif item.name.startswith("xor2"):
                code += ('\tasm("xor %%0, %%1, %%2" : "=r" (%s) : "r" (%s), "r" (%s) : %s );\n'
                        % (output, inputs[0], inputs[1], clobber))
            elif item.name.startswith("xnor2"):
                code += ('\tasm("xor %%0, %%1, %%2\\nnot %%0, %%0" : "=r" (%s) : "r" (%s), "r" (%s) : %s );\n'
                        % (output, inputs[0], inputs[1], clobber))
            else:
                print('Error: Unhandled item name', item.name)
                return ''
        code += '\tasm("########## END ##########");\n'

        return code

    def generateStatementsOutput(self):
        """ Generate statements to store output temp vars to pointers """
        code = ""
        outputs = [item.replace("[", "_").replace("]", "_") for item in self.parser.outputsList]
        for item in outputs:
            code += "\t*" + item + '_p = ' + item + ";\n"
        return code

